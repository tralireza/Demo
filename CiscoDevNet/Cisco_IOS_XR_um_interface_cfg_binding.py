# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal

import builtins as __builtin__
long = int
class yc_sub_interface_type_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_sub_interface_type(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-um-interface-cfg - based on the path /interfaces/interface/sub-interface-type. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specify type of sub-interface
  """
  _pyangbind_elements = {}

  

class yc_restart_penalty_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening_decay_half_life_reuse_threshold_suppress_threshold_max_suppress_time_restart_penalty(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-um-interface-cfg - based on the path /interfaces/interface/dampening/decay-half-life/reuse-threshold/suppress-threshold/max-suppress-time/restart-penalty. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Restart penalty
  """
  __slots__ = ('_path_helper', '_extmethods', '__value',)

  _yang_name = 'restart-penalty'
  _yang_namespace = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..20000']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'dampening', 'decay-half-life', 'reuse-threshold', 'suppress-threshold', 'max-suppress-time', 'restart-penalty']

  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /interfaces/interface/dampening/decay_half_life/reuse_threshold/suppress_threshold/max_suppress_time/restart_penalty/value (uint32)

    YANG Description: Restart penalty
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /interfaces/interface/dampening/decay_half_life/reuse_threshold/suppress_threshold/max_suppress_time/restart_penalty/value (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Restart penalty
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..20000']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..20000']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..20000']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)

  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('value', value), ])


class yc_max_suppress_time_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening_decay_half_life_reuse_threshold_suppress_threshold_max_suppress_time(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-um-interface-cfg - based on the path /interfaces/interface/dampening/decay-half-life/reuse-threshold/suppress-threshold/max-suppress-time. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Max suppress time (in minutes)
  """
  __slots__ = ('_path_helper', '_extmethods', '__value','__restart_penalty',)

  _yang_name = 'max-suppress-time'
  _yang_namespace = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)
    self.__restart_penalty = YANGDynClass(base=yc_restart_penalty_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening_decay_half_life_reuse_threshold_suppress_threshold_max_suppress_time_restart_penalty, is_container='container', yang_name="restart-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'dampening', 'decay-half-life', 'reuse-threshold', 'suppress-threshold', 'max-suppress-time']

  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /interfaces/interface/dampening/decay_half_life/reuse_threshold/suppress_threshold/max_suppress_time/value (uint32)

    YANG Description: Max suppress time (in minutes)
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /interfaces/interface/dampening/decay_half_life/reuse_threshold/suppress_threshold/max_suppress_time/value (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Max suppress time (in minutes)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)


  def _get_restart_penalty(self):
    """
    Getter method for restart_penalty, mapped from YANG variable /interfaces/interface/dampening/decay_half_life/reuse_threshold/suppress_threshold/max_suppress_time/restart_penalty (container)

    YANG Description: Restart penalty
    """
    return self.__restart_penalty
      
  def _set_restart_penalty(self, v, load=False):
    """
    Setter method for restart_penalty, mapped from YANG variable /interfaces/interface/dampening/decay_half_life/reuse_threshold/suppress_threshold/max_suppress_time/restart_penalty (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_penalty is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_penalty() directly.

    YANG Description: Restart penalty
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_restart_penalty_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening_decay_half_life_reuse_threshold_suppress_threshold_max_suppress_time_restart_penalty, is_container='container', yang_name="restart-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_penalty must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_restart_penalty_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening_decay_half_life_reuse_threshold_suppress_threshold_max_suppress_time_restart_penalty, is_container='container', yang_name="restart-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)""",
        })

    self.__restart_penalty = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_penalty(self):
    self.__restart_penalty = YANGDynClass(base=yc_restart_penalty_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening_decay_half_life_reuse_threshold_suppress_threshold_max_suppress_time_restart_penalty, is_container='container', yang_name="restart-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

  value = __builtin__.property(_get_value, _set_value)
  restart_penalty = __builtin__.property(_get_restart_penalty, _set_restart_penalty)


  _pyangbind_elements = OrderedDict([('value', value), ('restart_penalty', restart_penalty), ])


class yc_suppress_threshold_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening_decay_half_life_reuse_threshold_suppress_threshold(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-um-interface-cfg - based on the path /interfaces/interface/dampening/decay-half-life/reuse-threshold/suppress-threshold. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Suppress threshold
  """
  __slots__ = ('_path_helper', '_extmethods', '__value','__max_suppress_time',)

  _yang_name = 'suppress-threshold'
  _yang_namespace = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)
    self.__max_suppress_time = YANGDynClass(base=yc_max_suppress_time_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening_decay_half_life_reuse_threshold_suppress_threshold_max_suppress_time, is_container='container', yang_name="max-suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'dampening', 'decay-half-life', 'reuse-threshold', 'suppress-threshold']

  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /interfaces/interface/dampening/decay_half_life/reuse_threshold/suppress_threshold/value (uint32)

    YANG Description: Suppress threshold
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /interfaces/interface/dampening/decay_half_life/reuse_threshold/suppress_threshold/value (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Suppress threshold
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)


  def _get_max_suppress_time(self):
    """
    Getter method for max_suppress_time, mapped from YANG variable /interfaces/interface/dampening/decay_half_life/reuse_threshold/suppress_threshold/max_suppress_time (container)

    YANG Description: Max suppress time (in minutes)
    """
    return self.__max_suppress_time
      
  def _set_max_suppress_time(self, v, load=False):
    """
    Setter method for max_suppress_time, mapped from YANG variable /interfaces/interface/dampening/decay_half_life/reuse_threshold/suppress_threshold/max_suppress_time (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_suppress_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_suppress_time() directly.

    YANG Description: Max suppress time (in minutes)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_max_suppress_time_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening_decay_half_life_reuse_threshold_suppress_threshold_max_suppress_time, is_container='container', yang_name="max-suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_suppress_time must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_max_suppress_time_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening_decay_half_life_reuse_threshold_suppress_threshold_max_suppress_time, is_container='container', yang_name="max-suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)""",
        })

    self.__max_suppress_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_suppress_time(self):
    self.__max_suppress_time = YANGDynClass(base=yc_max_suppress_time_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening_decay_half_life_reuse_threshold_suppress_threshold_max_suppress_time, is_container='container', yang_name="max-suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

  value = __builtin__.property(_get_value, _set_value)
  max_suppress_time = __builtin__.property(_get_max_suppress_time, _set_max_suppress_time)


  _pyangbind_elements = OrderedDict([('value', value), ('max_suppress_time', max_suppress_time), ])


class yc_reuse_threshold_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening_decay_half_life_reuse_threshold(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-um-interface-cfg - based on the path /interfaces/interface/dampening/decay-half-life/reuse-threshold. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Reuse threshold
  """
  __slots__ = ('_path_helper', '_extmethods', '__value','__suppress_threshold',)

  _yang_name = 'reuse-threshold'
  _yang_namespace = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)
    self.__suppress_threshold = YANGDynClass(base=yc_suppress_threshold_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening_decay_half_life_reuse_threshold_suppress_threshold, is_container='container', yang_name="suppress-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'dampening', 'decay-half-life', 'reuse-threshold']

  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /interfaces/interface/dampening/decay_half_life/reuse_threshold/value (uint32)

    YANG Description: Reuse threshold
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /interfaces/interface/dampening/decay_half_life/reuse_threshold/value (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Reuse threshold
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)


  def _get_suppress_threshold(self):
    """
    Getter method for suppress_threshold, mapped from YANG variable /interfaces/interface/dampening/decay_half_life/reuse_threshold/suppress_threshold (container)

    YANG Description: Suppress threshold
    """
    return self.__suppress_threshold
      
  def _set_suppress_threshold(self, v, load=False):
    """
    Setter method for suppress_threshold, mapped from YANG variable /interfaces/interface/dampening/decay_half_life/reuse_threshold/suppress_threshold (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress_threshold() directly.

    YANG Description: Suppress threshold
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_suppress_threshold_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening_decay_half_life_reuse_threshold_suppress_threshold, is_container='container', yang_name="suppress-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress_threshold must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_suppress_threshold_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening_decay_half_life_reuse_threshold_suppress_threshold, is_container='container', yang_name="suppress-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)""",
        })

    self.__suppress_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress_threshold(self):
    self.__suppress_threshold = YANGDynClass(base=yc_suppress_threshold_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening_decay_half_life_reuse_threshold_suppress_threshold, is_container='container', yang_name="suppress-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

  value = __builtin__.property(_get_value, _set_value)
  suppress_threshold = __builtin__.property(_get_suppress_threshold, _set_suppress_threshold)


  _pyangbind_elements = OrderedDict([('value', value), ('suppress_threshold', suppress_threshold), ])


class yc_decay_half_life_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening_decay_half_life(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-um-interface-cfg - based on the path /interfaces/interface/dampening/decay-half-life. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Decay half life (in minutes)
  """
  __slots__ = ('_path_helper', '_extmethods', '__value','__reuse_threshold',)

  _yang_name = 'decay-half-life'
  _yang_namespace = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..45']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)
    self.__reuse_threshold = YANGDynClass(base=yc_reuse_threshold_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening_decay_half_life_reuse_threshold, is_container='container', yang_name="reuse-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'dampening', 'decay-half-life']

  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /interfaces/interface/dampening/decay_half_life/value (uint32)

    YANG Description: Decay half life (in minutes)
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /interfaces/interface/dampening/decay_half_life/value (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Decay half life (in minutes)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..45']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..45']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..45']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)


  def _get_reuse_threshold(self):
    """
    Getter method for reuse_threshold, mapped from YANG variable /interfaces/interface/dampening/decay_half_life/reuse_threshold (container)

    YANG Description: Reuse threshold
    """
    return self.__reuse_threshold
      
  def _set_reuse_threshold(self, v, load=False):
    """
    Setter method for reuse_threshold, mapped from YANG variable /interfaces/interface/dampening/decay_half_life/reuse_threshold (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reuse_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reuse_threshold() directly.

    YANG Description: Reuse threshold
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_reuse_threshold_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening_decay_half_life_reuse_threshold, is_container='container', yang_name="reuse-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reuse_threshold must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_reuse_threshold_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening_decay_half_life_reuse_threshold, is_container='container', yang_name="reuse-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)""",
        })

    self.__reuse_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reuse_threshold(self):
    self.__reuse_threshold = YANGDynClass(base=yc_reuse_threshold_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening_decay_half_life_reuse_threshold, is_container='container', yang_name="reuse-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

  value = __builtin__.property(_get_value, _set_value)
  reuse_threshold = __builtin__.property(_get_reuse_threshold, _set_reuse_threshold)


  _pyangbind_elements = OrderedDict([('value', value), ('reuse_threshold', reuse_threshold), ])


class yc_dampening_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-um-interface-cfg - based on the path /interfaces/interface/dampening. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: configure state dampening on the given interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__decay_half_life',)

  _yang_name = 'dampening'
  _yang_namespace = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__decay_half_life = YANGDynClass(base=yc_decay_half_life_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening_decay_half_life, is_container='container', yang_name="decay-half-life", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'dampening']

  def _get_decay_half_life(self):
    """
    Getter method for decay_half_life, mapped from YANG variable /interfaces/interface/dampening/decay_half_life (container)

    YANG Description: Decay half life (in minutes)
    """
    return self.__decay_half_life
      
  def _set_decay_half_life(self, v, load=False):
    """
    Setter method for decay_half_life, mapped from YANG variable /interfaces/interface/dampening/decay_half_life (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decay_half_life is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decay_half_life() directly.

    YANG Description: Decay half life (in minutes)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_decay_half_life_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening_decay_half_life, is_container='container', yang_name="decay-half-life", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decay_half_life must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_decay_half_life_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening_decay_half_life, is_container='container', yang_name="decay-half-life", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)""",
        })

    self.__decay_half_life = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decay_half_life(self):
    self.__decay_half_life = YANGDynClass(base=yc_decay_half_life_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening_decay_half_life, is_container='container', yang_name="decay-half-life", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

  decay_half_life = __builtin__.property(_get_decay_half_life, _set_decay_half_life)


  _pyangbind_elements = OrderedDict([('decay_half_life', decay_half_life), ])


class yc_frame_relay_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_encapsulation_frame_relay(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-um-interface-cfg - based on the path /interfaces/interface/encapsulation/frame-relay. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Frame Relay networks
  """
  _pyangbind_elements = {}

  

class yc_encapsulation_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_encapsulation(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-um-interface-cfg - based on the path /interfaces/interface/encapsulation. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Set the encapsulation on an interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__frame_relay',)

  _yang_name = 'encapsulation'
  _yang_namespace = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__frame_relay = YANGDynClass(base=yc_frame_relay_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_encapsulation_frame_relay, is_container='container', yang_name="frame-relay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'encapsulation']

  def _get_frame_relay(self):
    """
    Getter method for frame_relay, mapped from YANG variable /interfaces/interface/encapsulation/frame_relay (container)

    YANG Description: Frame Relay networks
    """
    return self.__frame_relay
      
  def _set_frame_relay(self, v, load=False):
    """
    Setter method for frame_relay, mapped from YANG variable /interfaces/interface/encapsulation/frame_relay (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frame_relay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frame_relay() directly.

    YANG Description: Frame Relay networks
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_frame_relay_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_encapsulation_frame_relay, is_container='container', yang_name="frame-relay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frame_relay must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_frame_relay_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_encapsulation_frame_relay, is_container='container', yang_name="frame-relay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)""",
        })

    self.__frame_relay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frame_relay(self):
    self.__frame_relay = YANGDynClass(base=yc_frame_relay_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_encapsulation_frame_relay, is_container='container', yang_name="frame-relay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

  frame_relay = __builtin__.property(_get_frame_relay, _set_frame_relay)


  _pyangbind_elements = OrderedDict([('frame_relay', frame_relay), ])


class yc_events_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_logging_events(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-um-interface-cfg - based on the path /interfaces/interface/logging/events. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Per-interface logging events
  """
  _pyangbind_elements = {}

  

class yc_logging_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_logging(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-um-interface-cfg - based on the path /interfaces/interface/logging. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Per-interface logging configuration
  """
  __slots__ = ('_path_helper', '_extmethods', '__events',)

  _yang_name = 'logging'
  _yang_namespace = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__events = YANGDynClass(base=yc_events_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_logging_events, is_container='container', yang_name="events", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'logging']

  def _get_events(self):
    """
    Getter method for events, mapped from YANG variable /interfaces/interface/logging/events (container)

    YANG Description: Per-interface logging events
    """
    return self.__events
      
  def _set_events(self, v, load=False):
    """
    Setter method for events, mapped from YANG variable /interfaces/interface/logging/events (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_events is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_events() directly.

    YANG Description: Per-interface logging events
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_events_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_logging_events, is_container='container', yang_name="events", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """events must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_events_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_logging_events, is_container='container', yang_name="events", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)""",
        })

    self.__events = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_events(self):
    self.__events = YANGDynClass(base=yc_events_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_logging_events, is_container='container', yang_name="events", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

  events = __builtin__.property(_get_events, _set_events)


  _pyangbind_elements = OrderedDict([('events', events), ])


class yc_interface_Cisco_IOS_XR_um_interface_cfg__interfaces_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-um-interface-cfg - based on the path /interfaces/interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Interface configuration subcommands
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface_name','__sub_interface_type','__dampening','__encapsulation','__mtu','__logging','__bandwidth','__description',)

  _yang_name = 'interface'
  _yang_namespace = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface_name = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[a-zA-Z0-9.:_/-]+'}), is_leaf=True, yang_name="interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='xr:Interface-name', is_config=True)
    self.__sub_interface_type = YANGDynClass(base=yc_sub_interface_type_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_sub_interface_type, is_container='container', yang_name="sub-interface-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    self.__dampening = YANGDynClass(base=yc_dampening_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening, is_container='container', yang_name="dampening", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    self.__encapsulation = YANGDynClass(base=yc_encapsulation_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_encapsulation, is_container='container', yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['64..65535']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)
    self.__logging = YANGDynClass(base=yc_logging_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_logging, is_container='container', yang_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'length': ['1..1024']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface']

  def _get_interface_name(self):
    """
    Getter method for interface_name, mapped from YANG variable /interfaces/interface/interface_name (xr:Interface-name)

    YANG Description: Interface configuration subcommands
    """
    return self.__interface_name
      
  def _set_interface_name(self, v, load=False):
    """
    Setter method for interface_name, mapped from YANG variable /interfaces/interface/interface_name (xr:Interface-name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_name() directly.

    YANG Description: Interface configuration subcommands
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[a-zA-Z0-9.:_/-]+'}), is_leaf=True, yang_name="interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='xr:Interface-name', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_name must be of a type compatible with xr:Interface-name""",
          'defined-type': "xr:Interface-name",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[a-zA-Z0-9.:_/-]+'}), is_leaf=True, yang_name="interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='xr:Interface-name', is_config=True)""",
        })

    self.__interface_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_name(self):
    self.__interface_name = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[a-zA-Z0-9.:_/-]+'}), is_leaf=True, yang_name="interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='xr:Interface-name', is_config=True)


  def _get_sub_interface_type(self):
    """
    Getter method for sub_interface_type, mapped from YANG variable /interfaces/interface/sub_interface_type (container)

    YANG Description: Specify type of sub-interface
    """
    return self.__sub_interface_type
      
  def _set_sub_interface_type(self, v, load=False):
    """
    Setter method for sub_interface_type, mapped from YANG variable /interfaces/interface/sub_interface_type (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sub_interface_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sub_interface_type() directly.

    YANG Description: Specify type of sub-interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_sub_interface_type_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_sub_interface_type, is_container='container', yang_name="sub-interface-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sub_interface_type must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_sub_interface_type_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_sub_interface_type, is_container='container', yang_name="sub-interface-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)""",
        })

    self.__sub_interface_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sub_interface_type(self):
    self.__sub_interface_type = YANGDynClass(base=yc_sub_interface_type_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_sub_interface_type, is_container='container', yang_name="sub-interface-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)


  def _get_dampening(self):
    """
    Getter method for dampening, mapped from YANG variable /interfaces/interface/dampening (container)

    YANG Description: configure state dampening on the given interface
    """
    return self.__dampening
      
  def _set_dampening(self, v, load=False):
    """
    Setter method for dampening, mapped from YANG variable /interfaces/interface/dampening (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dampening is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dampening() directly.

    YANG Description: configure state dampening on the given interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dampening_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening, is_container='container', yang_name="dampening", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dampening must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dampening_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening, is_container='container', yang_name="dampening", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)""",
        })

    self.__dampening = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dampening(self):
    self.__dampening = YANGDynClass(base=yc_dampening_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_dampening, is_container='container', yang_name="dampening", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)


  def _get_encapsulation(self):
    """
    Getter method for encapsulation, mapped from YANG variable /interfaces/interface/encapsulation (container)

    YANG Description: Set the encapsulation on an interface
    """
    return self.__encapsulation
      
  def _set_encapsulation(self, v, load=False):
    """
    Setter method for encapsulation, mapped from YANG variable /interfaces/interface/encapsulation (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encapsulation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encapsulation() directly.

    YANG Description: Set the encapsulation on an interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_encapsulation_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_encapsulation, is_container='container', yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encapsulation must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_encapsulation_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_encapsulation, is_container='container', yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)""",
        })

    self.__encapsulation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encapsulation(self):
    self.__encapsulation = YANGDynClass(base=yc_encapsulation_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_encapsulation, is_container='container', yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /interfaces/interface/mtu (uint32)

    YANG Description: Set the MTU on an interface
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /interfaces/interface/mtu (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: Set the MTU on an interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['64..65535']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['64..65535']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['64..65535']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)


  def _get_logging(self):
    """
    Getter method for logging, mapped from YANG variable /interfaces/interface/logging (container)

    YANG Description: Per-interface logging configuration
    """
    return self.__logging
      
  def _set_logging(self, v, load=False):
    """
    Setter method for logging, mapped from YANG variable /interfaces/interface/logging (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logging is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logging() directly.

    YANG Description: Per-interface logging configuration
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_logging_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_logging, is_container='container', yang_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logging must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_logging_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_logging, is_container='container', yang_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)""",
        })

    self.__logging = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logging(self):
    self.__logging = YANGDynClass(base=yc_logging_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_logging, is_container='container', yang_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)


  def _get_bandwidth(self):
    """
    Getter method for bandwidth, mapped from YANG variable /interfaces/interface/bandwidth (uint32)

    YANG Description: Set the bandwidth of an interface
    """
    return self.__bandwidth
      
  def _set_bandwidth(self, v, load=False):
    """
    Setter method for bandwidth, mapped from YANG variable /interfaces/interface/bandwidth (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bandwidth() directly.

    YANG Description: Set the bandwidth of an interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bandwidth must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bandwidth(self):
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /interfaces/interface/description (string)

    YANG Description: Set description for this interface
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /interfaces/interface/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Set description for this interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'length': ['1..1024']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'length': ['1..1024']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'length': ['1..1024']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='string', is_config=True)

  interface_name = __builtin__.property(_get_interface_name, _set_interface_name)
  sub_interface_type = __builtin__.property(_get_sub_interface_type, _set_sub_interface_type)
  dampening = __builtin__.property(_get_dampening, _set_dampening)
  encapsulation = __builtin__.property(_get_encapsulation, _set_encapsulation)
  mtu = __builtin__.property(_get_mtu, _set_mtu)
  logging = __builtin__.property(_get_logging, _set_logging)
  bandwidth = __builtin__.property(_get_bandwidth, _set_bandwidth)
  description = __builtin__.property(_get_description, _set_description)


  _pyangbind_elements = OrderedDict([('interface_name', interface_name), ('sub_interface_type', sub_interface_type), ('dampening', dampening), ('encapsulation', encapsulation), ('mtu', mtu), ('logging', logging), ('bandwidth', bandwidth), ('description', description), ])


class yc_sub_interface_type_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_sub_interface_type(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-um-interface-cfg - based on the path /interfaces/interface-preconfigure/sub-interface-type. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specify type of sub-interface
  """
  _pyangbind_elements = {}

  

class yc_restart_penalty_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening_decay_half_life_reuse_threshold_suppress_threshold_max_suppress_time_restart_penalty(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-um-interface-cfg - based on the path /interfaces/interface-preconfigure/dampening/decay-half-life/reuse-threshold/suppress-threshold/max-suppress-time/restart-penalty. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Restart penalty
  """
  __slots__ = ('_path_helper', '_extmethods', '__value',)

  _yang_name = 'restart-penalty'
  _yang_namespace = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..20000']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface-preconfigure', 'dampening', 'decay-half-life', 'reuse-threshold', 'suppress-threshold', 'max-suppress-time', 'restart-penalty']

  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /interfaces/interface_preconfigure/dampening/decay_half_life/reuse_threshold/suppress_threshold/max_suppress_time/restart_penalty/value (uint32)

    YANG Description: Restart penalty
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /interfaces/interface_preconfigure/dampening/decay_half_life/reuse_threshold/suppress_threshold/max_suppress_time/restart_penalty/value (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Restart penalty
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..20000']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..20000']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..20000']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)

  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('value', value), ])


class yc_max_suppress_time_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening_decay_half_life_reuse_threshold_suppress_threshold_max_suppress_time(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-um-interface-cfg - based on the path /interfaces/interface-preconfigure/dampening/decay-half-life/reuse-threshold/suppress-threshold/max-suppress-time. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Max suppress time (in minutes)
  """
  __slots__ = ('_path_helper', '_extmethods', '__value','__restart_penalty',)

  _yang_name = 'max-suppress-time'
  _yang_namespace = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)
    self.__restart_penalty = YANGDynClass(base=yc_restart_penalty_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening_decay_half_life_reuse_threshold_suppress_threshold_max_suppress_time_restart_penalty, is_container='container', yang_name="restart-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface-preconfigure', 'dampening', 'decay-half-life', 'reuse-threshold', 'suppress-threshold', 'max-suppress-time']

  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /interfaces/interface_preconfigure/dampening/decay_half_life/reuse_threshold/suppress_threshold/max_suppress_time/value (uint32)

    YANG Description: Max suppress time (in minutes)
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /interfaces/interface_preconfigure/dampening/decay_half_life/reuse_threshold/suppress_threshold/max_suppress_time/value (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Max suppress time (in minutes)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)


  def _get_restart_penalty(self):
    """
    Getter method for restart_penalty, mapped from YANG variable /interfaces/interface_preconfigure/dampening/decay_half_life/reuse_threshold/suppress_threshold/max_suppress_time/restart_penalty (container)

    YANG Description: Restart penalty
    """
    return self.__restart_penalty
      
  def _set_restart_penalty(self, v, load=False):
    """
    Setter method for restart_penalty, mapped from YANG variable /interfaces/interface_preconfigure/dampening/decay_half_life/reuse_threshold/suppress_threshold/max_suppress_time/restart_penalty (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_penalty is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_penalty() directly.

    YANG Description: Restart penalty
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_restart_penalty_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening_decay_half_life_reuse_threshold_suppress_threshold_max_suppress_time_restart_penalty, is_container='container', yang_name="restart-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_penalty must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_restart_penalty_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening_decay_half_life_reuse_threshold_suppress_threshold_max_suppress_time_restart_penalty, is_container='container', yang_name="restart-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)""",
        })

    self.__restart_penalty = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_penalty(self):
    self.__restart_penalty = YANGDynClass(base=yc_restart_penalty_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening_decay_half_life_reuse_threshold_suppress_threshold_max_suppress_time_restart_penalty, is_container='container', yang_name="restart-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

  value = __builtin__.property(_get_value, _set_value)
  restart_penalty = __builtin__.property(_get_restart_penalty, _set_restart_penalty)


  _pyangbind_elements = OrderedDict([('value', value), ('restart_penalty', restart_penalty), ])


class yc_suppress_threshold_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening_decay_half_life_reuse_threshold_suppress_threshold(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-um-interface-cfg - based on the path /interfaces/interface-preconfigure/dampening/decay-half-life/reuse-threshold/suppress-threshold. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Suppress threshold
  """
  __slots__ = ('_path_helper', '_extmethods', '__value','__max_suppress_time',)

  _yang_name = 'suppress-threshold'
  _yang_namespace = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)
    self.__max_suppress_time = YANGDynClass(base=yc_max_suppress_time_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening_decay_half_life_reuse_threshold_suppress_threshold_max_suppress_time, is_container='container', yang_name="max-suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface-preconfigure', 'dampening', 'decay-half-life', 'reuse-threshold', 'suppress-threshold']

  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /interfaces/interface_preconfigure/dampening/decay_half_life/reuse_threshold/suppress_threshold/value (uint32)

    YANG Description: Suppress threshold
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /interfaces/interface_preconfigure/dampening/decay_half_life/reuse_threshold/suppress_threshold/value (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Suppress threshold
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)


  def _get_max_suppress_time(self):
    """
    Getter method for max_suppress_time, mapped from YANG variable /interfaces/interface_preconfigure/dampening/decay_half_life/reuse_threshold/suppress_threshold/max_suppress_time (container)

    YANG Description: Max suppress time (in minutes)
    """
    return self.__max_suppress_time
      
  def _set_max_suppress_time(self, v, load=False):
    """
    Setter method for max_suppress_time, mapped from YANG variable /interfaces/interface_preconfigure/dampening/decay_half_life/reuse_threshold/suppress_threshold/max_suppress_time (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_suppress_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_suppress_time() directly.

    YANG Description: Max suppress time (in minutes)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_max_suppress_time_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening_decay_half_life_reuse_threshold_suppress_threshold_max_suppress_time, is_container='container', yang_name="max-suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_suppress_time must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_max_suppress_time_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening_decay_half_life_reuse_threshold_suppress_threshold_max_suppress_time, is_container='container', yang_name="max-suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)""",
        })

    self.__max_suppress_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_suppress_time(self):
    self.__max_suppress_time = YANGDynClass(base=yc_max_suppress_time_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening_decay_half_life_reuse_threshold_suppress_threshold_max_suppress_time, is_container='container', yang_name="max-suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

  value = __builtin__.property(_get_value, _set_value)
  max_suppress_time = __builtin__.property(_get_max_suppress_time, _set_max_suppress_time)


  _pyangbind_elements = OrderedDict([('value', value), ('max_suppress_time', max_suppress_time), ])


class yc_reuse_threshold_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening_decay_half_life_reuse_threshold(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-um-interface-cfg - based on the path /interfaces/interface-preconfigure/dampening/decay-half-life/reuse-threshold. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Reuse threshold
  """
  __slots__ = ('_path_helper', '_extmethods', '__value','__suppress_threshold',)

  _yang_name = 'reuse-threshold'
  _yang_namespace = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)
    self.__suppress_threshold = YANGDynClass(base=yc_suppress_threshold_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening_decay_half_life_reuse_threshold_suppress_threshold, is_container='container', yang_name="suppress-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface-preconfigure', 'dampening', 'decay-half-life', 'reuse-threshold']

  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /interfaces/interface_preconfigure/dampening/decay_half_life/reuse_threshold/value (uint32)

    YANG Description: Reuse threshold
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /interfaces/interface_preconfigure/dampening/decay_half_life/reuse_threshold/value (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Reuse threshold
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)


  def _get_suppress_threshold(self):
    """
    Getter method for suppress_threshold, mapped from YANG variable /interfaces/interface_preconfigure/dampening/decay_half_life/reuse_threshold/suppress_threshold (container)

    YANG Description: Suppress threshold
    """
    return self.__suppress_threshold
      
  def _set_suppress_threshold(self, v, load=False):
    """
    Setter method for suppress_threshold, mapped from YANG variable /interfaces/interface_preconfigure/dampening/decay_half_life/reuse_threshold/suppress_threshold (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress_threshold() directly.

    YANG Description: Suppress threshold
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_suppress_threshold_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening_decay_half_life_reuse_threshold_suppress_threshold, is_container='container', yang_name="suppress-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress_threshold must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_suppress_threshold_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening_decay_half_life_reuse_threshold_suppress_threshold, is_container='container', yang_name="suppress-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)""",
        })

    self.__suppress_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress_threshold(self):
    self.__suppress_threshold = YANGDynClass(base=yc_suppress_threshold_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening_decay_half_life_reuse_threshold_suppress_threshold, is_container='container', yang_name="suppress-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

  value = __builtin__.property(_get_value, _set_value)
  suppress_threshold = __builtin__.property(_get_suppress_threshold, _set_suppress_threshold)


  _pyangbind_elements = OrderedDict([('value', value), ('suppress_threshold', suppress_threshold), ])


class yc_decay_half_life_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening_decay_half_life(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-um-interface-cfg - based on the path /interfaces/interface-preconfigure/dampening/decay-half-life. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Decay half life (in minutes)
  """
  __slots__ = ('_path_helper', '_extmethods', '__value','__reuse_threshold',)

  _yang_name = 'decay-half-life'
  _yang_namespace = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..45']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)
    self.__reuse_threshold = YANGDynClass(base=yc_reuse_threshold_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening_decay_half_life_reuse_threshold, is_container='container', yang_name="reuse-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface-preconfigure', 'dampening', 'decay-half-life']

  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /interfaces/interface_preconfigure/dampening/decay_half_life/value (uint32)

    YANG Description: Decay half life (in minutes)
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /interfaces/interface_preconfigure/dampening/decay_half_life/value (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Decay half life (in minutes)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..45']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..45']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..45']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)


  def _get_reuse_threshold(self):
    """
    Getter method for reuse_threshold, mapped from YANG variable /interfaces/interface_preconfigure/dampening/decay_half_life/reuse_threshold (container)

    YANG Description: Reuse threshold
    """
    return self.__reuse_threshold
      
  def _set_reuse_threshold(self, v, load=False):
    """
    Setter method for reuse_threshold, mapped from YANG variable /interfaces/interface_preconfigure/dampening/decay_half_life/reuse_threshold (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reuse_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reuse_threshold() directly.

    YANG Description: Reuse threshold
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_reuse_threshold_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening_decay_half_life_reuse_threshold, is_container='container', yang_name="reuse-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reuse_threshold must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_reuse_threshold_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening_decay_half_life_reuse_threshold, is_container='container', yang_name="reuse-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)""",
        })

    self.__reuse_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reuse_threshold(self):
    self.__reuse_threshold = YANGDynClass(base=yc_reuse_threshold_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening_decay_half_life_reuse_threshold, is_container='container', yang_name="reuse-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

  value = __builtin__.property(_get_value, _set_value)
  reuse_threshold = __builtin__.property(_get_reuse_threshold, _set_reuse_threshold)


  _pyangbind_elements = OrderedDict([('value', value), ('reuse_threshold', reuse_threshold), ])


class yc_dampening_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-um-interface-cfg - based on the path /interfaces/interface-preconfigure/dampening. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: configure state dampening on the given interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__decay_half_life',)

  _yang_name = 'dampening'
  _yang_namespace = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__decay_half_life = YANGDynClass(base=yc_decay_half_life_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening_decay_half_life, is_container='container', yang_name="decay-half-life", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface-preconfigure', 'dampening']

  def _get_decay_half_life(self):
    """
    Getter method for decay_half_life, mapped from YANG variable /interfaces/interface_preconfigure/dampening/decay_half_life (container)

    YANG Description: Decay half life (in minutes)
    """
    return self.__decay_half_life
      
  def _set_decay_half_life(self, v, load=False):
    """
    Setter method for decay_half_life, mapped from YANG variable /interfaces/interface_preconfigure/dampening/decay_half_life (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decay_half_life is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decay_half_life() directly.

    YANG Description: Decay half life (in minutes)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_decay_half_life_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening_decay_half_life, is_container='container', yang_name="decay-half-life", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decay_half_life must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_decay_half_life_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening_decay_half_life, is_container='container', yang_name="decay-half-life", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)""",
        })

    self.__decay_half_life = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decay_half_life(self):
    self.__decay_half_life = YANGDynClass(base=yc_decay_half_life_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening_decay_half_life, is_container='container', yang_name="decay-half-life", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

  decay_half_life = __builtin__.property(_get_decay_half_life, _set_decay_half_life)


  _pyangbind_elements = OrderedDict([('decay_half_life', decay_half_life), ])


class yc_frame_relay_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_encapsulation_frame_relay(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-um-interface-cfg - based on the path /interfaces/interface-preconfigure/encapsulation/frame-relay. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Frame Relay networks
  """
  _pyangbind_elements = {}

  

class yc_encapsulation_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_encapsulation(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-um-interface-cfg - based on the path /interfaces/interface-preconfigure/encapsulation. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Set the encapsulation on an interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__frame_relay',)

  _yang_name = 'encapsulation'
  _yang_namespace = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__frame_relay = YANGDynClass(base=yc_frame_relay_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_encapsulation_frame_relay, is_container='container', yang_name="frame-relay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface-preconfigure', 'encapsulation']

  def _get_frame_relay(self):
    """
    Getter method for frame_relay, mapped from YANG variable /interfaces/interface_preconfigure/encapsulation/frame_relay (container)

    YANG Description: Frame Relay networks
    """
    return self.__frame_relay
      
  def _set_frame_relay(self, v, load=False):
    """
    Setter method for frame_relay, mapped from YANG variable /interfaces/interface_preconfigure/encapsulation/frame_relay (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frame_relay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frame_relay() directly.

    YANG Description: Frame Relay networks
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_frame_relay_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_encapsulation_frame_relay, is_container='container', yang_name="frame-relay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frame_relay must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_frame_relay_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_encapsulation_frame_relay, is_container='container', yang_name="frame-relay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)""",
        })

    self.__frame_relay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frame_relay(self):
    self.__frame_relay = YANGDynClass(base=yc_frame_relay_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_encapsulation_frame_relay, is_container='container', yang_name="frame-relay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

  frame_relay = __builtin__.property(_get_frame_relay, _set_frame_relay)


  _pyangbind_elements = OrderedDict([('frame_relay', frame_relay), ])


class yc_events_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_logging_events(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-um-interface-cfg - based on the path /interfaces/interface-preconfigure/logging/events. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Per-interface logging events
  """
  _pyangbind_elements = {}

  

class yc_logging_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_logging(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-um-interface-cfg - based on the path /interfaces/interface-preconfigure/logging. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Per-interface logging configuration
  """
  __slots__ = ('_path_helper', '_extmethods', '__events',)

  _yang_name = 'logging'
  _yang_namespace = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__events = YANGDynClass(base=yc_events_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_logging_events, is_container='container', yang_name="events", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface-preconfigure', 'logging']

  def _get_events(self):
    """
    Getter method for events, mapped from YANG variable /interfaces/interface_preconfigure/logging/events (container)

    YANG Description: Per-interface logging events
    """
    return self.__events
      
  def _set_events(self, v, load=False):
    """
    Setter method for events, mapped from YANG variable /interfaces/interface_preconfigure/logging/events (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_events is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_events() directly.

    YANG Description: Per-interface logging events
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_events_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_logging_events, is_container='container', yang_name="events", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """events must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_events_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_logging_events, is_container='container', yang_name="events", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)""",
        })

    self.__events = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_events(self):
    self.__events = YANGDynClass(base=yc_events_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_logging_events, is_container='container', yang_name="events", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

  events = __builtin__.property(_get_events, _set_events)


  _pyangbind_elements = OrderedDict([('events', events), ])


class yc_interface_preconfigure_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-um-interface-cfg - based on the path /interfaces/interface-preconfigure. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specify a preconfig interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface_name','__sub_interface_type','__dampening','__encapsulation','__mtu','__logging','__bandwidth','__description',)

  _yang_name = 'interface-preconfigure'
  _yang_namespace = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface_name = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[a-zA-Z0-9.:_/-]+'}), is_leaf=True, yang_name="interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='xr:Interface-name', is_config=True)
    self.__sub_interface_type = YANGDynClass(base=yc_sub_interface_type_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_sub_interface_type, is_container='container', yang_name="sub-interface-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    self.__dampening = YANGDynClass(base=yc_dampening_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening, is_container='container', yang_name="dampening", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    self.__encapsulation = YANGDynClass(base=yc_encapsulation_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_encapsulation, is_container='container', yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['64..65535']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)
    self.__logging = YANGDynClass(base=yc_logging_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_logging, is_container='container', yang_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'length': ['1..1024']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface-preconfigure']

  def _get_interface_name(self):
    """
    Getter method for interface_name, mapped from YANG variable /interfaces/interface_preconfigure/interface_name (xr:Interface-name)

    YANG Description: Interface configuration subcommands
    """
    return self.__interface_name
      
  def _set_interface_name(self, v, load=False):
    """
    Setter method for interface_name, mapped from YANG variable /interfaces/interface_preconfigure/interface_name (xr:Interface-name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_name() directly.

    YANG Description: Interface configuration subcommands
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[a-zA-Z0-9.:_/-]+'}), is_leaf=True, yang_name="interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='xr:Interface-name', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_name must be of a type compatible with xr:Interface-name""",
          'defined-type': "xr:Interface-name",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[a-zA-Z0-9.:_/-]+'}), is_leaf=True, yang_name="interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='xr:Interface-name', is_config=True)""",
        })

    self.__interface_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_name(self):
    self.__interface_name = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[a-zA-Z0-9.:_/-]+'}), is_leaf=True, yang_name="interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='xr:Interface-name', is_config=True)


  def _get_sub_interface_type(self):
    """
    Getter method for sub_interface_type, mapped from YANG variable /interfaces/interface_preconfigure/sub_interface_type (container)

    YANG Description: Specify type of sub-interface
    """
    return self.__sub_interface_type
      
  def _set_sub_interface_type(self, v, load=False):
    """
    Setter method for sub_interface_type, mapped from YANG variable /interfaces/interface_preconfigure/sub_interface_type (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sub_interface_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sub_interface_type() directly.

    YANG Description: Specify type of sub-interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_sub_interface_type_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_sub_interface_type, is_container='container', yang_name="sub-interface-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sub_interface_type must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_sub_interface_type_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_sub_interface_type, is_container='container', yang_name="sub-interface-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)""",
        })

    self.__sub_interface_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sub_interface_type(self):
    self.__sub_interface_type = YANGDynClass(base=yc_sub_interface_type_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_sub_interface_type, is_container='container', yang_name="sub-interface-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)


  def _get_dampening(self):
    """
    Getter method for dampening, mapped from YANG variable /interfaces/interface_preconfigure/dampening (container)

    YANG Description: configure state dampening on the given interface
    """
    return self.__dampening
      
  def _set_dampening(self, v, load=False):
    """
    Setter method for dampening, mapped from YANG variable /interfaces/interface_preconfigure/dampening (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dampening is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dampening() directly.

    YANG Description: configure state dampening on the given interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dampening_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening, is_container='container', yang_name="dampening", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dampening must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dampening_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening, is_container='container', yang_name="dampening", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)""",
        })

    self.__dampening = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dampening(self):
    self.__dampening = YANGDynClass(base=yc_dampening_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_dampening, is_container='container', yang_name="dampening", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)


  def _get_encapsulation(self):
    """
    Getter method for encapsulation, mapped from YANG variable /interfaces/interface_preconfigure/encapsulation (container)

    YANG Description: Set the encapsulation on an interface
    """
    return self.__encapsulation
      
  def _set_encapsulation(self, v, load=False):
    """
    Setter method for encapsulation, mapped from YANG variable /interfaces/interface_preconfigure/encapsulation (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encapsulation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encapsulation() directly.

    YANG Description: Set the encapsulation on an interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_encapsulation_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_encapsulation, is_container='container', yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encapsulation must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_encapsulation_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_encapsulation, is_container='container', yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)""",
        })

    self.__encapsulation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encapsulation(self):
    self.__encapsulation = YANGDynClass(base=yc_encapsulation_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_encapsulation, is_container='container', yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /interfaces/interface_preconfigure/mtu (uint32)

    YANG Description: Set the MTU on an interface
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /interfaces/interface_preconfigure/mtu (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: Set the MTU on an interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['64..65535']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['64..65535']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['64..65535']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)


  def _get_logging(self):
    """
    Getter method for logging, mapped from YANG variable /interfaces/interface_preconfigure/logging (container)

    YANG Description: Per-interface logging configuration
    """
    return self.__logging
      
  def _set_logging(self, v, load=False):
    """
    Setter method for logging, mapped from YANG variable /interfaces/interface_preconfigure/logging (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logging is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logging() directly.

    YANG Description: Per-interface logging configuration
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_logging_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_logging, is_container='container', yang_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logging must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_logging_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_logging, is_container='container', yang_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)""",
        })

    self.__logging = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logging(self):
    self.__logging = YANGDynClass(base=yc_logging_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure_logging, is_container='container', yang_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)


  def _get_bandwidth(self):
    """
    Getter method for bandwidth, mapped from YANG variable /interfaces/interface_preconfigure/bandwidth (uint32)

    YANG Description: Set the bandwidth of an interface
    """
    return self.__bandwidth
      
  def _set_bandwidth(self, v, load=False):
    """
    Setter method for bandwidth, mapped from YANG variable /interfaces/interface_preconfigure/bandwidth (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bandwidth() directly.

    YANG Description: Set the bandwidth of an interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bandwidth must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bandwidth(self):
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='uint32', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /interfaces/interface_preconfigure/description (string)

    YANG Description: Set description for this interface
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /interfaces/interface_preconfigure/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Set description for this interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'length': ['1..1024']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'length': ['1..1024']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'length': ['1..1024']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='string', is_config=True)

  interface_name = __builtin__.property(_get_interface_name, _set_interface_name)
  sub_interface_type = __builtin__.property(_get_sub_interface_type, _set_sub_interface_type)
  dampening = __builtin__.property(_get_dampening, _set_dampening)
  encapsulation = __builtin__.property(_get_encapsulation, _set_encapsulation)
  mtu = __builtin__.property(_get_mtu, _set_mtu)
  logging = __builtin__.property(_get_logging, _set_logging)
  bandwidth = __builtin__.property(_get_bandwidth, _set_bandwidth)
  description = __builtin__.property(_get_description, _set_description)


  _pyangbind_elements = OrderedDict([('interface_name', interface_name), ('sub_interface_type', sub_interface_type), ('dampening', dampening), ('encapsulation', encapsulation), ('mtu', mtu), ('logging', logging), ('bandwidth', bandwidth), ('description', description), ])


class yc_interfaces_Cisco_IOS_XR_um_interface_cfg__interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-um-interface-cfg - based on the path /interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Interface configuration
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface','__interface_preconfigure',)

  _yang_name = 'interfaces'
  _yang_namespace = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=YANGListType("interface_name",yc_interface_Cisco_IOS_XR_um_interface_cfg__interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='list', is_config=True)
    self.__interface_preconfigure = YANGDynClass(base=YANGListType("interface_name",yc_interface_preconfigure_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure, yang_name="interface-preconfigure", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-name', extensions=None), is_container='list', yang_name="interface-preconfigure", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /interfaces/interface (list)

    YANG Description: Interface configuration subcommands
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /interfaces/interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Interface configuration subcommands
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("interface_name",yc_interface_Cisco_IOS_XR_um_interface_cfg__interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("interface_name",yc_interface_Cisco_IOS_XR_um_interface_cfg__interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='list', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=YANGListType("interface_name",yc_interface_Cisco_IOS_XR_um_interface_cfg__interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='list', is_config=True)


  def _get_interface_preconfigure(self):
    """
    Getter method for interface_preconfigure, mapped from YANG variable /interfaces/interface_preconfigure (list)

    YANG Description: Specify a preconfig interface
    """
    return self.__interface_preconfigure
      
  def _set_interface_preconfigure(self, v, load=False):
    """
    Setter method for interface_preconfigure, mapped from YANG variable /interfaces/interface_preconfigure (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_preconfigure is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_preconfigure() directly.

    YANG Description: Specify a preconfig interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("interface_name",yc_interface_preconfigure_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure, yang_name="interface-preconfigure", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-name', extensions=None), is_container='list', yang_name="interface-preconfigure", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_preconfigure must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("interface_name",yc_interface_preconfigure_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure, yang_name="interface-preconfigure", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-name', extensions=None), is_container='list', yang_name="interface-preconfigure", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='list', is_config=True)""",
        })

    self.__interface_preconfigure = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_preconfigure(self):
    self.__interface_preconfigure = YANGDynClass(base=YANGListType("interface_name",yc_interface_preconfigure_Cisco_IOS_XR_um_interface_cfg__interfaces_interface_preconfigure, yang_name="interface-preconfigure", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-name', extensions=None), is_container='list', yang_name="interface-preconfigure", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='list', is_config=True)

  interface = __builtin__.property(_get_interface, _set_interface)
  interface_preconfigure = __builtin__.property(_get_interface_preconfigure, _set_interface_preconfigure)


  _pyangbind_elements = OrderedDict([('interface', interface), ('interface_preconfigure', interface_preconfigure), ])


class Cisco_IOS_XR_um_interface_cfg(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-um-interface-cfg - based on the path /Cisco-IOS-XR-um-interface-cfg. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a collection of YANG definitions
for Cisco IOS-XR interface package configuration.

This YANG module augments the
modules with configuration data.

Copyright (c) 2019, 2021 by Cisco Systems, Inc.
All rights reserved.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interfaces',)

  _yang_name = 'Cisco-IOS-XR-um-interface-cfg'
  _yang_namespace = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interfaces = YANGDynClass(base=yc_interfaces_Cisco_IOS_XR_um_interface_cfg__interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /interfaces (container)

    YANG Description: Interface configuration
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: Interface configuration
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interfaces_Cisco_IOS_XR_um_interface_cfg__interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interfaces_Cisco_IOS_XR_um_interface_cfg__interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=yc_interfaces_Cisco_IOS_XR_um_interface_cfg__interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', defining_module='Cisco-IOS-XR-um-interface-cfg', yang_type='container', is_config=True)

  interfaces = __builtin__.property(_get_interfaces, _set_interfaces)


  _pyangbind_elements = OrderedDict([('interfaces', interfaces), ])


class cisco_semver(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module cisco-semver - based on the path /cisco-semver. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This YANG module defines semantic version for Cisco defined YANG models.
Copyright (c) 2019 by Cisco Systems, Inc.
All rights reserved.
  """
  _pyangbind_elements = {}

  

class Cisco_IOS_XR_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-types - based on the path /Cisco-IOS-XR-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a collection of IOS-XR derived YANG data
types.

Copyright (c) 2013-2019 by Cisco Systems, Inc.
All rights reserved.
  """
  _pyangbind_elements = {}

  

class tailf_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module tailf-common - based on the path /tailf-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines all Tail-f YANG extensions statements
and common YANG types.
  """
  _pyangbind_elements = {}

  

class tailf_meta_extensions(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module tailf-meta-extensions - based on the path /tailf-meta-extensions. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule defines Tail-f YANG meta extensions statements.
  """
  _pyangbind_elements = {}

  

class tailf_cli_extensions(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module tailf-cli-extensions - based on the path /tailf-cli-extensions. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines all Tail-f YANG extensions statements
related to CLI customization.

See also the 'display-' statements and the 'alt-name' statement
in tailf-common.yang.
  """
  _pyangbind_elements = {}

  

class tailf_cli_extensions(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module tailf-cli-extensions - based on the path /tailf-cli-extensions. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines all Tail-f YANG extensions statements
related to CLI customization.

See also the 'display-' statements and the 'alt-name' statement
in tailf-common.yang.
  """
  _pyangbind_elements = {}

  

class tailf_meta_extensions(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module tailf-meta-extensions - based on the path /tailf-meta-extensions. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule defines Tail-f YANG meta extensions statements.
  """
  _pyangbind_elements = {}

  

class tailf_meta_extensions(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module tailf-meta-extensions - based on the path /tailf-meta-extensions. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule defines Tail-f YANG meta extensions statements.
  """
  _pyangbind_elements = {}

  

